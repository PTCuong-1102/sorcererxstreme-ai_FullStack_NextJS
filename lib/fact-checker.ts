/**
 * Fact Checker Module
 * Provides functionality to verify AI-generated content against Wikipedia sources
 * and process citations
 */

import { WikipediaSummary } from './wikipedia';

export interface VerificationResult {
  score: number | 'Kh√¥ng x√°c ƒë·ªãnh';
  level: 'Cao' | 'Trung b√¨nh' | 'Th·∫•p' | 'Kh√¥ng x√°c ƒë·ªãnh';
  details?: string;
}

export interface CitationProcessResult {
  formattedContent: string;
  sources: Array<{
    title: string;
    url: string;
    used: boolean;
  }>;
  citationCount: number;
}

export interface FactCheckResult {
  verification: VerificationResult;
  citations: CitationProcessResult;
  enhancedContent: string;
}

/**
 * Verify AI-generated content against Wikipedia sources
 * @param aiContent - The content generated by AI
 * @param wikiSources - Array of Wikipedia summaries to compare against
 * @returns Verification result with score and level
 */
export function verifyContent(
  aiContent: string, 
  wikiSources: (WikipediaSummary | null)[]
): VerificationResult {
  try {
    // Filter out null sources
    const validSources = wikiSources.filter((source): source is WikipediaSummary => 
      source !== null && source.extract.length > 0
    );
    
    if (validSources.length === 0) {
      return {
        score: 'Kh√¥ng x√°c ƒë·ªãnh',
        level: 'Kh√¥ng x√°c ƒë·ªãnh',
        details: 'Kh√¥ng c√≥ ngu·ªìn Wikipedia ƒë·ªÉ so s√°nh'
      };
    }
    
    // Simple verification algorithm
    let totalMatches = 0;
    let totalChecks = 0;
    
    // Extract key phrases from Wikipedia content
    const keyPhrases = extractKeyPhrases(validSources);
    const aiContentLower = aiContent.toLowerCase();
    
    // Count matches
    keyPhrases.forEach(phrase => {
      totalChecks++;
      if (aiContentLower.includes(phrase.toLowerCase())) {
        totalMatches++;
      }
    });
    
    // Calculate score as percentage
    const score = totalChecks > 0 ? Math.round((totalMatches / totalChecks) * 100) : 0;
    
    // Determine verification level
    let level: 'Cao' | 'Trung b√¨nh' | 'Th·∫•p' | 'Kh√¥ng x√°c ƒë·ªãnh';
    if (score >= 70) {
      level = 'Cao';
    } else if (score >= 40) {
      level = 'Trung b√¨nh';
    } else if (score > 0) {
      level = 'Th·∫•p';
    } else {
      level = 'Kh√¥ng x√°c ƒë·ªãnh';
    }
    
    return {
      score,
      level,
      details: `T√¨m th·∫•y ${totalMatches}/${totalChecks} ƒëi·ªÉm kh·ªõp v·ªõi ngu·ªìn Wikipedia`
    };
    
  } catch (error) {
    console.error('Error in verifyContent:', error);
    return {
      score: 'Kh√¥ng x√°c ƒë·ªãnh',
      level: 'Kh√¥ng x√°c ƒë·ªãnh',
      details: 'L·ªói khi x√°c th·ª±c n·ªôi dung'
    };
  }
}

/**
 * Extract key phrases from Wikipedia sources for comparison
 * @param sources - Array of Wikipedia summaries
 * @returns Array of key phrases
 */
function extractKeyPhrases(sources: WikipediaSummary[]): string[] {
  const phrases: string[] = [];
  
  sources.forEach(source => {
    const content = source.extract;
    
    // Split into sentences and extract meaningful phrases
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 10);
    
    sentences.forEach(sentence => {
      const words = sentence.trim().split(/\s+/);
      
      // Extract phrases of 3-6 words that contain meaningful content
      for (let i = 0; i < words.length - 2; i++) {
        for (let len = 3; len <= Math.min(6, words.length - i); len++) {
          const phrase = words.slice(i, i + len).join(' ').trim();
          
          // Only add phrases that contain meaningful content (not just common words)
          if (phrase.length > 10 && !isCommonPhrase(phrase)) {
            phrases.push(phrase);
          }
        }
      }
    });
  });
  
  // Remove duplicates and return
  return [...new Set(phrases)];
}

/**
 * Check if a phrase is too common to be useful for verification
 * @param phrase - The phrase to check
 * @returns true if the phrase is too common
 */
function isCommonPhrase(phrase: string): boolean {
  const commonWords = [
    'l√† m·ªôt', 'c·ªßa m·ªôt', 'trong m·ªôt', 'v·ªõi m·ªôt', 'theo m·ªôt',
    'ƒë∆∞·ª£c s·ª≠ d·ª•ng', 'th∆∞·ªùng ƒë∆∞·ª£c', 'c√≥ th·ªÉ', 's·∫Ω ƒë∆∞·ª£c',
    'v√† ƒë∆∞·ª£c', 'ho·∫∑c ƒë∆∞·ª£c', 'c≈©ng ƒë∆∞·ª£c', 'ƒë√£ ƒë∆∞·ª£c'
  ];
  
  const phraseLower = phrase.toLowerCase();
  return commonWords.some(common => phraseLower.includes(common));
}

/**
 * Process citations in AI-generated content
 * @param aiContent - Content from AI that may contain citation markers
 * @param wikiSources - Wikipedia sources used
 * @returns Processed content with proper citation links and source list
 */
export function processCitations(
  aiContent: string, 
  wikiSources: (WikipediaSummary | null)[]
): CitationProcessResult {
  try {
    let formattedContent = aiContent;
    const sources: Array<{ title: string; url: string; used: boolean }> = [];
    let citationCount = 0;
    
    // Create source map
    const validSources = wikiSources.filter((source): source is WikipediaSummary => 
      source !== null
    );
    
    validSources.forEach(source => {
      sources.push({
        title: source.title,
        url: source.url,
        used: false
      });
    });
    
    // Process citation markers: [content](source:URL)
    const citationRegex = /\[([^\]]+)\]\(source:([^)]+)\)/g;
    
    formattedContent = formattedContent.replace(citationRegex, (match, content, url) => {
      citationCount++;
      
      // Find matching source and mark as used
      const matchingSource = sources.find(s => s.url === url);
      if (matchingSource) {
        matchingSource.used = true;
      }
      
      // Return formatted citation link
      return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="citation-link" title="Ngu·ªìn: Wikipedia">${content}</a><sup>[${citationCount}]</sup>`;
    });
    
    // Also look for direct Wikipedia links
    const wikiLinkRegex = /https:\/\/vi\.wikipedia\.org\/wiki\/[^\s\])]*/g;
    const foundLinks = formattedContent.match(wikiLinkRegex) || [];
    
    foundLinks.forEach(link => {
      const decodedTitle = decodeURIComponent(link.split('/wiki/')[1]?.replace(/_/g, ' ') || '');
      const matchingSource = sources.find(s => s.title === decodedTitle);
      if (matchingSource) {
        matchingSource.used = true;
      }
    });
    
    return {
      formattedContent,
      sources,
      citationCount
    };
    
  } catch (error) {
    console.error('Error in processCitations:', error);
    return {
      formattedContent: aiContent,
      sources: [],
      citationCount: 0
    };
  }
}

/**
 * Complete fact-checking process for AI content
 * @param aiContent - Content generated by AI
 * @param wikiSources - Wikipedia sources to verify against
 * @returns Complete fact-check result
 */
export function factCheckContent(
  aiContent: string,
  wikiSources: (WikipediaSummary | null)[]
): FactCheckResult {
  const verification = verifyContent(aiContent, wikiSources);
  const citations = processCitations(aiContent, wikiSources);
  
  // Enhance content with verification badge
  const verificationBadge = createVerificationBadge(verification);
  const enhancedContent = `${citations.formattedContent}\n\n${verificationBadge}`;
  
  return {
    verification,
    citations,
    enhancedContent
  };
}

/**
 * Create a verification badge HTML
 * @param verification - Verification result
 * @returns HTML string for verification badge
 */
function createVerificationBadge(verification: VerificationResult): string {
  let badgeClass = 'verification-unknown';
  let badgeText = 'Kh√¥ng x√°c ƒë·ªãnh';
  
  if (typeof verification.score === 'number') {
    badgeText = `ƒê·ªô x√°c th·ª±c: ${verification.score}% - ${verification.level}`;
    
    switch (verification.level) {
      case 'Cao':
        badgeClass = 'verification-high';
        break;
      case 'Trung b√¨nh':
        badgeClass = 'verification-medium';
        break;
      case 'Th·∫•p':
        badgeClass = 'verification-low';
        break;
    }
  }
  
  return `<div class="verification-badge ${badgeClass}">
    <span class="verification-icon">üîç</span>
    <span class="verification-text">${badgeText}</span>
    ${verification.details ? `<span class="verification-details">${verification.details}</span>` : ''}
  </div>`;
}

/**
 * Create source reference section
 * @param sources - Array of sources
 * @returns HTML string for source references
 */
export function createSourceReferences(sources: Array<{ title: string; url: string; used: boolean }>): string {
  if (sources.length === 0) {
    return '';
  }
  
  const usedSources = sources.filter(s => s.used);
  
  if (usedSources.length === 0) {
    return '<div class="source-references"><h4>Ngu·ªìn tham kh·∫£o:</h4><p>Kh√¥ng c√≥ ngu·ªìn ƒë∆∞·ª£c tr√≠ch d·∫´n tr·ª±c ti·∫øp</p></div>';
  }
  
  const sourceList = usedSources.map((source, index) => 
    `<li><a href="${source.url}" target="_blank" rel="noopener noreferrer">[${index + 1}] ${source.title} - Wikipedia</a></li>`
  ).join('');
  
  return `<div class="source-references">
    <h4>Ngu·ªìn tham kh·∫£o:</h4>
    <ul>${sourceList}</ul>
  </div>`;
}
